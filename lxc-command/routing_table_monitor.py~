import os
import sys
import time
import subprocess
from datetime import datetime
import math

arg_list = sys.argv

Radio_IP_start = "10.100.0.0"

read_interval = 0.1 # every 100 ms

#Radio_IP_start = "10.0.2.255"


def IP2Int(ip):
    o = map(int, ip.split('.'))
    res = (16777216 * o[0]) + (65536 * o[1]) + (256 * o[2]) + o[3]
    return res


def Int2IP(ipnum):
    o1 = int(ipnum / 16777216) % 256
    o2 = int(ipnum / 65536) % 256
    o3 = int(ipnum / 256) % 256
    o4 = int(ipnum) % 256
    return '%(o1)s.%(o2)s.%(o3)s.%(o4)s' % locals()

ppid = os.getppid()
print "Parent ppid", ppid


def usage() :
	print "Incorrect usage. Correct usage : sudo python routing_table_monitor.py <This-node-IP> <number of nodes> <number of secs to run >"

if len(arg_list) != 4 :

	usage()
	sys.exit(1)

my_IP = arg_list[1]

my_IP_index = IP2Int(my_IP) - IP2Int(Radio_IP_start) - 1
n_nodes = int(arg_list[2])
n_secs = int(arg_list[3])

if n_nodes <= 1 :
	sys.exit(1)

node_count = []
node_count_variance = []
node_available  = []
total_no_of_oscillations = 0
total_no_of_down_nodes = 0

i = 0
while i < n_nodes :
	node_count.append(0)
	node_available.append(-1)
	node_count_variance.append(0)
	i = i + 1


i = 1
while i <= int(n_secs/read_interval) :



	p = subprocess.Popen(['/sbin/route', '-n'], stdout=subprocess.PIPE,stderr=subprocess.PIPE, shell=False)
	time.sleep(read_interval)
	out, err = p.communicate()
	ls = out.split('\n')
	j = 2
	prev_present_IP_index = -1
	while j < len(ls) -1 :
		entry_list = ls[j].split(' ')
		entry_IP = entry_list[0]
		entry_IP_index = IP2Int(entry_IP) - IP2Int(Radio_IP_start) - 1
		k = prev_present_IP_index + 1
		while k < entry_IP_index and entry_IP_index >= 0 and entry_IP_index < n_nodes:
			if node_available[k] == 1 :
				print "Node-",k + 1," Went down at ", datetime.now()
				node_available[k] = 0
				total_no_of_down_nodes = total_no_of_down_nodes + 1

			k = k + 1

		if entry_IP_index >= 0 and entry_IP_index < n_nodes and node_available[entry_IP_index] == 0 :
			print "Node-",entry_IP_index + 1, " Came back up at ", datetime.now()
			node_available[entry_IP_index] = 1
			total_no_of_oscillations = total_no_of_oscillations + 1
			

		elif entry_IP_index >= 0 and entry_IP_index < n_nodes and node_available[entry_IP_index] == -1 :
			node_available[entry_IP_index] = 1
			
		if entry_IP_index >= 0 and entry_IP_index < n_nodes :
			node_count[entry_IP_index] = node_count[entry_IP_index] + 1
			prev_present_IP_index = entry_IP_index
		j = j + 1


	i = i + 1

	
i = 0
sum_value = 0
variance_value = 0
while i < n_nodes :
	if i != my_IP_index :
		sum_value = sum_value + node_count[i]
		variance_value = variance_value + (node_count[i]*node_count[i])

		node_count[i] = float(node_count[i])/float(n_secs/read_interval)
		node_count_variance[i] = float(node_count[i]*(1 - node_count[i]))
		print "Node : ", i + 1, " Mean Availability (per Sec) : ", node_count[i], " Variance of Availablility (per Sec) : ", node_count_variance[i]
	
	i = i + 1

if n_nodes > 1 :
	mean = float(sum_value*read_interval)/float(n_nodes - 1)
	variance = float(variance_value*read_interval*read_interval)/float(n_nodes - 1)
	variance = variance - (mean*mean)
	print "Total Mean Availablity (Secs) : ", float(mean)
	print "Total Std deviation of Availability (Secs) : ", math.sqrt(float(variance))
	print "Total number of oscillations : ", total_no_of_oscillations
	
