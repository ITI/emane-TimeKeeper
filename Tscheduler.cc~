#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <stdarg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include "TimeKeeper_functions.h"
#include "TimeKeeper_definitions.h"
#include "utility_functions.h"


#define FALSE 0
#define TRUE 1
#define INFO 1
#define ERROR 2
#define NOT_SET -1
#define MAX_CMD_LEN 1000
#define PID_SIZE 100


int getopt(int argc, char * const argv[],const char *optstring);

extern char *optarg;
extern int optind, opterr, optopt;

void DEBUG(char * str, int level){

	printf("%s : %s",(level == INFO ? "INFO" : "ERROR"), str);
	if(level == ERROR)
		exit(-1); 
}

void flush_buffer(char * buf, int size){

	int i = 0;
	for(i = 0; i < size; i++)
		buf[i] = '\0';

}

int main(int argc, char**argv){

	 FILE *fd = popen("lsmod | grep Timekeeper", "r");
	 FILE * pFile;
	 FILE * pFile2;
	 int opt;
 	 char buf[16];
	 long time_quanta = NOT_SET;
	 int is_default_time_quanta = FALSE;
	 long tdf = NOT_SET;
	 char ** cmd = NULL;
	 int pid = NOT_SET;
	 int cmd_specified = FALSE;
 	 int n_cmd_args = 0;
	 int cmd_start_index;
	 int total_cmd_string_length = 0;
	 int i = 0, j = 0;
	 char command[MAX_CMD_LEN];
	 int max_tdf = -1;
	 int line_no = 0;
	 int curr_tdf;
	 struct stat sts;


 	 if (fread (buf, 1, sizeof (buf), fd) == 0) // if there is some result the module must be loaded
	    	DEBUG("Timekeeper module is not loaded\n",ERROR);


	 while ((opt = getopt(argc, argv, "q:d:p:r")) != -1) {
               switch (opt) {

               case 'q':
                   time_quanta = atoi(optarg);
                   break;
               case 'd':
                   tdf = atoi(optarg);
                   break;
		case 'p' :
		   pid = atoi(optarg);
		   break;
		case 'r' :
		   stopExp();
		   DEBUG("All previously assigned jobs removed from Timekeeper's control\n", INFO);
		   exit(0);
		   break;
		   		

               default: /* '?' */
                   printf("Usage: [-q time_quanta (nanoseconds)] [-d tdf] [-p pid (optional)] [command with args (optional)] [ r (remove all previously assigned jobs from timekeeper's control - superseeds all options]\n");
		   printf("Either the pid or the command must be specified. If pid is specified and was already dilated, its dilation factor would be changed\n");
		   printf("TDF default value is 1, time_quanta default value is 300ms. If it is not specified and was already set in a previous run, it would remain unchanged\n");
                   exit(-1);
               }
        }	
	
	if(time_quanta < NOT_SET || time_quanta == 0)
		DEBUG("Time quanta must be greater than 0\n",ERROR);
			
	if(tdf < NOT_SET || tdf == 0)
		DEBUG("Tdf must be greater than 0\n",ERROR);

	if(pid < NOT_SET || pid == 0)
		DEBUG("Pid must be greater than 0\n",ERROR);


	if(time_quanta == NOT_SET){
		is_default_time_quanta = TRUE;
		time_quanta = 300000000;
	}

	if(tdf == NOT_SET)
		tdf = 1;
	
		
	cmd_start_index = optind;
        while(argv[optind] != NULL){
		optind++;
		n_cmd_args++;
	}
	if(n_cmd_args >= 1){
		cmd_specified = TRUE;
		n_cmd_args = n_cmd_args - 1;
	}
		
	if(!cmd_specified && pid == NOT_SET)
		DEBUG("Expected atleast ProcessID or valid command\n",ERROR);
	
	if(cmd_specified && pid > 0)
		DEBUG("Either cmd or ProcessID must be specified. Not both.\n",ERROR);

	if(cmd_specified){	
		cmd =  malloc(sizeof(char *) * (n_cmd_args + 2));
		
		for(i = 0; i < n_cmd_args; i++){
			cmd[i] = argv[cmd_start_index + i];
			total_cmd_string_length += strlen(cmd[i]) + 1;

		}
		cmd[n_cmd_args + 1] = NULL;

		char * copy_dest = command;
		for(i = 0; i < n_cmd_args ; i++){
			sprintf(copy_dest,"%s ",cmd[i]);
			copy_dest += strlen(cmd[i]);				
		}

		command[total_cmd_string_length] = '\0';


	}

	
	
	if(access("TimekeeperScheduled.txt",F_OK) != -1){
		// File does not exist create it and add this pid/ cmd's pid with the specified tdf.

		if(!cmd_specified)
			DEBUG("No such specifed PID exists. Aborting.\n", ERROR);
		
		pFile = fopen("TimekeeperScheduled.txt","a");
		if(pFile == NULL)
			DEBUG("Unable to set scheduling parameters - cannot create helper file. Aborted\n", ERROR);

		
		pid = fork();
		if(pid < 0)
			DEBUG("Unable to fork command. Aborting.\n",ERROR);

		if(pid == 0){
			/* child process */
			system(command);
			return 0;
		}
		max_tdf = tdf;

		// set new time quanta here.
		dilate_all(pid, tdf);
		addToExp(pid,-1);	
		synchronizeAndFreeze();
		startExp();

		fprintf(pFile,"%d\n",time_quanta);
		fprintf(pFile,"%d,%d,%s\n",pid,tdf,command);
		fclose(pFile);						

		
	}
	else{

	        char * line = NULL;
       	        size_t len = 0;
	        ssize_t read;
		char pid_string[PID_SIZE];
		long curr_pid;
		char proc_f_name[PID_SIZE];
		int not_found = TRUE;

		pFile = fopen("TimekeeperScheduled.txt", "r");
		pFile2 = fopen("temp.txt","w");
		fclose(pFile2);

		pFile2 = fopen("temp.txt","a");		
	        if (pFile == NULL || pFile2 == NULL)
			DEBUG("Unable to open helper file.  Aborting. Continuing with prev assigned jobs.\n", ERROR);

		// Stop prev timekeeper experiment.
		stopExp();

		while ((read = getline(&line, &len, pFile)) != -1) {
		        printf("Retrieved line of length %zu :\n", read);
			printf("%s", line);
			line_no++;
			if(line_no == 1){

				if(is_default_time_quanta)
					continue;
				else{
					fprintf(pFile2,"%d\n",time_quanta); // write new time_quanta. set new time quanta here.
					continue;
				}
			}
			
			flush_buffer(pid_string,PID_SIZE);
			flush_buffer(proc_f_name,PID_SIZE);
			i = 0;
			while(*(line + i) != ','){
				pid_string[i] = *(line + i);
				i++;
			}

			pid_string[i] = '\0';
			curr_pid = atoi(pid_string);
			
			flush_buffer(pid_string,PID_SIZE);

			i += 1;
			while(*(line + i) != ','){
				pid_string[i] = *(line + i);
				i++;
			}
			pid_string[i] = '\0';					
			curr_tdf = atoi(pid_string);

			sprintf(proc_f_name,"/proc/%d",curr_pid);
			if (stat(proc_f_name, &sts) == -1) {
  				// process doesn't exist
				continue;
			}

			if(curr_pid == pid) // update tdf
			{
				not_found = FALSE;
				i+= 1;				
				fprintf(pFile2,"%d,%d,%s\n",curr_pid,tdf,line + i);
				dilate_all(curr_pid,tdf);
				addToExp(curr_pid,-1);
				

			}
			else{
				i += 1;
				fprintf(pFile2,"%d,%d,%s\n",curr_pid,curr_tdf,line + i);
				dilate_all(curr_pid,curr_tdf);
				addToExp(curr_pid,-1);

			}

			
		
		}

		fclose(pFile2);
		fclose(pFile);

		if(not_found && !cmd_specified){
			// Continue with prev experiment
			synchronizeAndFreeze();
			startExp();
			DEBUG("Specified PID not found. Aborting. Continuing with prev assigned jobs.\n", ERROR);

		}

	
		// Write from temp.txt to TimekeeperScheduled.txt
		pFile = fopen("TimekeeperScheduled.txt", "w");
		fclose(pFile);
		pFile2 = fopen("temp.txt","r");
		pFile = fopen("TimekeeperScheduled.txt","a");

		if (pFile == NULL || pFile2 == NULL){
			stopExp();
			DEBUG("Unable to open helper file.  Aborting. Quitting any previous scheduling jobs.\n", ERROR);
		}



		if(cmd_specified){
			pid = fork();
			if(pid < 0){
				synchronizeAndFreeze();
				startExp();
				DEBUG("Unable to fork command. Aborting. Continuing with prev assigned jobs.\n",ERROR);

			}

			if(pid == 0){
				/* child process */
				system(command);
				return 0;
			}

			dilate_all(pid,tdf);
			addToExp(pid,-1);

			// Start Experiment - All checks passed.
			synchronizeAndFreeze();
			startExp();
			
		}

		// Update helper file.

		while ((read = getline(&line, &len, pFile2)) != -1) {

			fprintf(pFile,"%s\n",line);

		}

		if(cmd_specified)
			fprintf(pFile,"%d,%d,%s\n",pid,tdf,command);

		// Delete temp file.
		fclose(pFile2);
		fclose(pFile);

		remove("temp.txt");
		

	}	

}
